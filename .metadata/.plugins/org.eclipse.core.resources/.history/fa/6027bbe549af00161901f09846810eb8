package objects;

import helpers.Constants;

import java.awt.Color;
import java.awt.Graphics2D;
import java.util.Random;

import animationcore.objects.AbstractMovingObject;
import animationcore.physics.CVector;

public class ObjectWithGoal extends AbstractMovingObject {

	private Random r = new Random();
	
	private Integer ballRadius;
	private Color color;
	
	private Double goalX;
	private Double goalY;
	
	private Double longX;
	private Double longY;
	
	private Double normalizedX;
	private Double normalizedY;
	
	private Double magnitude;
	private float speed = 0.0f;
	
	public ObjectWithGoal(CVector velocity, CVector acceleration) {
		position = new CVector(0f, 0f);
		this.ballRadius = Constants.BALL_RADIUS;
		position.setX(new Float(Constants.PANEL_WIDTH / 2 - (ballRadius / 2)));
		position.setY(new Float(Constants.PANEL_HEIGHT / 2 - (ballRadius / 2)));
		
		goalX = Math.round(Constants.PANEL_WIDTH  * r.nextDouble());
		goalY = Constants.PANEL_HEIGHT * r.nextDouble();
		
		longX = goalX - position.getX();
		longY = goalY - position.getY();
		
		this.velocity = velocity;
		this.acceleration = acceleration;
		magnitude = Math.sqrt(longX*longX + longY*longY);
		this.color = Color.RED;
		
		System.out.printf("OBJECT PROPERTIES: \n"
				+ "POSITION: (%.2f , %.2f) \n"
				+ "GOAL: (%.2f , %.2f) \n"
				+ "LONG x: %.2f  LONG y: %.2f \n"
				+ "MAGNITUDE: %.2f \n \n",
				position.getX(), position.getY(), goalX, goalY, longX, longY, magnitude);
	}
	
	
	@Override
	public void move() throws Exception {
		
		velocity.add(acceleration);
		
		normalizedX = (longX / magnitude) * Constants.BALL_VELOCITY;
		normalizedY = (longY / magnitude) * Constants.BALL_VELOCITY;
		
		position.setX((float) (position.getX() + normalizedX));
		position.setY((float) (position.getY() + normalizedY));

		if (checkLimit()) {
			initializeNewLoop();
			throw new Exception();	
		
		}
	}

	@Override
	public void draw(Graphics2D g) {
		g.setPaint(color);
		g.fillOval(Math.round(position.getX()), Math.round(position.getY()), ballRadius, ballRadius);
		g.setColor(Color.WHITE);
		g.fillOval(Math.round(position.getX()) + 7, Math.round(position.getY()) + 5,
				(int)Math.round(ballRadius - (ballRadius * 0.75)), 
				(int)Math.round(ballRadius - (ballRadius * 0.35)));
	}
	
	private boolean checkLimit() {
		return Math.abs(position.getX() - goalX) < Math.abs(normalizedX)
				&& Math.abs(position.getY() - goalY) < Math.abs(normalizedY);
	}
	
	private void printInfo() {
		Double distance = Math.sqrt((longX.doubleValue() * longX.doubleValue()
				+ longY.doubleValue() * longY.doubleValue()));
		float time = Constants.END_TIME - Constants.START_TIME;
		if (time != 0.0 && distance != 0.0)
			speed = (float) (distance/time);
		
		if (speed > Constants.SPEED_MAX) {
			Constants.SPEED_MAX = speed;
			Constants.DEVIATION_NO_MAX++;
		} else if (speed < Constants.SPEED_MIN){
			Constants.SPEED_MIN = speed;
			Constants.DEVIATION_NO_MIN++;
		}
		
		System.out.printf(" Goal reached!!! "
				+ "\n GOAL: (%d , %.2f)  "
				+ "\n DISTANCE: %.2f"
				+ "\n TIME TOTAL: %.2f"
				+ "\n SPEED: %.2f px/msec"
				+ "\n SPEED DEVIATION: %.2f px/msec"
				+ "\n DEVIATION MAX: %d  DEVIATION MIN: %d"
				+ "\n TOTAL DEVIATION NO: %d"
				+ "\n\n --------------------------------- \n\n",
				goalX.intValue(), goalY,
				distance,time,speed, 
				Constants.SPEED_MAX - Constants.SPEED_MIN,
				Constants.DEVIATION_NO_MAX,Constants.DEVIATION_NO_MIN,
				Constants.DEVIATION_NO_MAX + Constants.DEVIATION_NO_MIN);
	}
	
	private void initializeNewLoop() {
		position.setX(goalX.floatValue());
		position.setY(goalY.floatValue());
		
		Constants.END_TIME = System.nanoTime() / Constants.NANO_TIME_SETUP;
		
		printInfo();
		
		goalX = Constants.PANEL_WIDTH  * r.nextDouble();
		goalY = Constants.PANEL_HEIGHT * r.nextDouble();
		
		longX = goalX - position.getX();
		longY = goalY - position.getY();
		magnitude = Math.sqrt(longX*longX + longY*longY);
	}

}
